# A dependent example

rm(list=ls())
library(mvtnorm)
#setwd("~/Dropbox/olivier/articles/tail_inference_high_dimensional_data/v1/code")
source(file = "algo.R")

#####
# 1. PLOT
#####
nplot <- 10^4
d <- 10^2 # dimension
d_indep <- 10 # the first 10 coordinates are RV independent
d_dep1 <- 5 # 5 couples of RV dependent => dim = 5*2=10
d_dep2 <- 5 # 5 triplets of RV dependent => dim = 5*3 = 15
d_tot <- d_indep + 2*d_dep1 + 3*d_dep2
n_faces <-d_indep + d_dep1 + d_dep2 # number of subsets which should appear

A <- matrix(1/runif(nplot*d_indep), ncol = nplot, nrow = d_indep) # Pareto 1: x -> 1/x

# The first dependent part dim = 2*5=10
B <- rep(NA, nplot)
for (i in 1:d_dep1){
  b_1 <- 1/runif(nplot) # pareto(1)
  b_2 <- b_1 + rexp(nplot) # the same pareto but perturbed by a normal
  B <- rbind(B,b_1, b_2)
}
B <- B[-1, ]

# The second dependent part
C <- rep(NA, nplot)
for (i in 1:d_dep1){
  c_1 <- 1/runif(nplot) # pareto(1)
  c_2 <- c_1 + rexp(nplot) # the same pareto but perturbed by a normal
  c_3 <- c_1 + rexp(nplot) # the same pareto but perturbed by a normal
  C <- rbind(C,c_1, c_2, c_3)
}
C <- C[-1, ]

# The non RV part:  Exponential x -> e^(-x)
D <- matrix(rexp(nplot*(d - d_indep - d_dep1*2 - d_dep2*3)), ncol = nplot, nrow = d - d_tot)
# => dim = 55
X <-rbind(A, B, C, D)

prop <- seq(0.005, 0.15, by = 0.005)
prop
length(prop)

result <- algo_plot(X, prop)
which_k <- which.min(result[ , 4])
which_k
k <- result[which_k , 1]
k
plot(result[ , 1], result[ , 4], type='l', ylim=c(0.4,0.8), xlab = "k", ylab = "KL(n)")
lines( x=c(k,k), y=c(0,result[ which_k, 4]), lty=3, lwd=2)
lines( x=c(0, k), y=c(result[ which_k, 4], result[ which_k, 4]),
       lty=3, lwd=2)
text(k, 0.55, paste("k_star =", k))

plot(result[ , 1], result[ , 3], type='l', ylim = c(0, 40), xlab = "k", ylab = "s0 = argmin KL(k)")
lines( x=c(k,k), y=c(0,result[ which_k, 3]), lty=3, lwd=2)
lines( x=c(0,k), y=c(result[ which_k3, 3],result[ which_k, 3]), lty=3, lwd=2)
text(k, 25, paste("s_star =", result[ which_k, 3]))


#####
# 2. SIMULATIONS
#####

N <- 100 # number of simulations
n <- c(7*10^3, 10^4, 3*10^4)
length_n <- length(n)

output <- matrix(rep(0, length_n*5), nrow = length_n) # the error vector
colnames(output) <- c("Type 1", "Type 2", "s_0", "k", "u")
rownames(output) <- paste("n=", n)

# the theoretical matrix that shoul appear
M_theor <- matrix(0, ncol=n_faces, nrow=d_tot)
diag(M_theor[1:d_indep, 1:d_indep]) <- rep(1, d_indep)
M_theor[(d_indep+1):(d_indep+2), d_indep+1] <- c(1,1)
M_theor[(d_indep+3):(d_indep+4), d_indep+2] <- c(1,1)
M_theor[(d_indep+5):(d_indep+6), d_indep+3] <- c(1,1)
M_theor[(d_indep+7):(d_indep+8), d_indep+4] <- c(1,1)
M_theor[(d_indep+9):(d_indep+10), d_indep+5] <- c(1,1)
M_theor[(d_indep+11):(d_indep+13), d_indep+6] <- c(1,1,1)
M_theor[(d_indep+14):(d_indep+16), d_indep+7] <- c(1,1,1)
M_theor[(d_indep+17):(d_indep+19), d_indep+8] <- c(1,1,1)
M_theor[(d_indep+20):(d_indep+22), d_indep+9] <- c(1,1,1)
M_theor[(d_indep+23):(d_indep+25), d_indep+10] <- c(1,1,1)

for (r in 1:length_n){
  for (l in 1:N){
    # The independent part: dim = 10
    A <- matrix(1/runif(n[r]*d_indep), ncol = n[r], nrow = d_indep) # Pareto 1: x -> 1/x
    
    # The first dependent part dim = 2*5=10
    B <- rep(NA, n[r])
    for (i in 1:d_dep1){
      b_1 <- 1/runif(n[r]) # pareto(1)
      b_2 <- b_1 + rexp(n[r]) # the same pareto but perturbed by a normal
      B <- rbind(B,b_1, b_2)
    }
    B <- B[-1, ]
    
    # The second dependent part
    C <- rep(NA, n[r])
    for (i in 1:d_dep1){
      c_1 <- 1/runif(n[r]) # pareto(1)
      c_2 <- c_1 + rexp(n[r]) # the same pareto but perturbed by a normal
      c_3 <- c_1 + rexp(n[r]) # the same pareto but perturbed by a normal
      C <- rbind(C,c_1, c_2, c_3)
    }
    C <- C[-1, ]
    
    # The non RV part:  Exponential x -> e^(-x)
    D <- matrix(rexp(n[r]*(d - d_indep - d_dep1*2 - d_dep2*3)), ncol = n[r], nrow = d - d_tot)
    # => dim = 65
    
    X3 <-rbind(A, B, C, D)
    
    subsets <- algo_subsets(X, prop)
    
    output[r, 3] <- output[r, 3] + subsets[[4]] # s_0
    output[r, 4] <- output[r, 4] + subsets[[2]] # k
    output[r, 5] <- output[r, 5] + subsets[[3]] # u
    
    M <- as.matrix(subsets[[1]][-(d3+1), 1:(subsets[[4]])])# the empirical matrix
    
    submatrix_below <- as.matrix(M[(d_tot+1):d, ])
    faces_below <- apply(submatrix_below, 2, sum)
    output[r, 1] <- output[r, 1] + sum(faces_below > 0) # type 1
    
    submatrix_above <- as.matrix(M[1:d_tot, ])
    
    output3[r, 1] <- output3[r, 1] + # type 1
      sum( tail( !duplicated( rbind(t(M_theor), t(submatrix_above)) ), ncol(submatrix_above) ) )
    
    output3[r,2] <- output3[r,2] + # type 2
      sum( tail( !duplicated( rbind(t(submatrix_above), t(M_theor)) ), ncol(M_theor) ) )
    
    print(c(r,l))
  }
}
output/N
